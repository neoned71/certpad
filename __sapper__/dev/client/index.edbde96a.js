import { S as SvelteComponentDev, i as init, s as safe_not_equal, d as dispatch_dev, p as globals, v as validate_slots, e as element, t as text, a as space, f as claim_element, g as children, h as claim_text, b as detach_dev, c as claim_space, k as add_location, j as attr_dev, l as src_url_equal, G as set_style, m as insert_hydration_dev, n as append_hydration_dev, B as listen_dev, w as set_data_dev, o as noop, E as run_all, I as binding_callbacks, A as set_input_value, C as prevent_default, J as create_component, q as query_selector_all, K as claim_component, L as mount_component, M as transition_in, N as transition_out, O as destroy_component } from './client.cd0f8950.js';
import { s as successkid } from './successkid.d53948a6.js';

/* eslint-env browser */
var browser = typeof self == 'object' ? self.FormData : window.FormData;

/* src/routes/_utils/imageUpload.svelte generated by Svelte v3.40.2 */

const { console: console_1$2 } = globals;
const file$2 = "src/routes/_utils/imageUpload.svelte";

// (47:8) {:else}
function create_else_block(ctx) {
	let img;
	let img_src_value;

	const block = {
		c: function create() {
			img = element("img");
			this.h();
		},
		l: function claim(nodes) {
			img = claim_element(nodes, "IMG", { class: true, src: true, alt: true });
			this.h();
		},
		h: function hydrate() {
			attr_dev(img, "class", "avatar svelte-16mpme9");
			if (!src_url_equal(img.src, img_src_value = "/images/blank.jpg")) attr_dev(img, "src", img_src_value);
			attr_dev(img, "alt", "");
			add_location(img, file$2, 47, 8, 1052);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, img, anchor);
		},
		p: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(img);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_else_block.name,
		type: "else",
		source: "(47:8) {:else}",
		ctx
	});

	return block;
}

// (45:8) {#if avatar}
function create_if_block(ctx) {
	let img;
	let img_src_value;

	const block = {
		c: function create() {
			img = element("img");
			this.h();
		},
		l: function claim(nodes) {
			img = claim_element(nodes, "IMG", { class: true, src: true, alt: true });
			this.h();
		},
		h: function hydrate() {
			attr_dev(img, "class", "avatar svelte-16mpme9");
			if (!src_url_equal(img.src, img_src_value = /*avatar*/ ctx[0])) attr_dev(img, "src", img_src_value);
			attr_dev(img, "alt", "");
			add_location(img, file$2, 45, 8, 983);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, img, anchor);
		},
		p: function update(ctx, dirty) {
			if (dirty & /*avatar*/ 1 && !src_url_equal(img.src, img_src_value = /*avatar*/ ctx[0])) {
				attr_dev(img, "src", img_src_value);
			}
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(img);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_if_block.name,
		type: "if",
		source: "(45:8) {#if avatar}",
		ctx
	});

	return block;
}

function create_fragment$2(ctx) {
	let div1;
	let h4;
	let t0;
	let t1;
	let t2;
	let t3;
	let img;
	let img_src_value;
	let t4;
	let div0;
	let t5;
	let t6;
	let input;
	let mounted;
	let dispose;

	function select_block_type(ctx, dirty) {
		if (/*avatar*/ ctx[0]) return create_if_block;
		return create_else_block;
	}

	let current_block_type = select_block_type(ctx);
	let if_block = current_block_type(ctx);

	const block = {
		c: function create() {
			div1 = element("div");
			h4 = element("h4");
			t0 = text(/*name*/ ctx[1]);
			t1 = text(" for the certificates");
			t2 = space();
			if_block.c();
			t3 = space();
			img = element("img");
			t4 = space();
			div0 = element("div");
			t5 = text("Choose Image");
			t6 = space();
			input = element("input");
			this.h();
		},
		l: function claim(nodes) {
			div1 = claim_element(nodes, "DIV", { id: true, class: true });
			var div1_nodes = children(div1);
			h4 = claim_element(div1_nodes, "H4", {});
			var h4_nodes = children(h4);
			t0 = claim_text(h4_nodes, /*name*/ ctx[1]);
			t1 = claim_text(h4_nodes, " for the certificates");
			h4_nodes.forEach(detach_dev);
			t2 = claim_space(div1_nodes);
			if_block.l(div1_nodes);
			t3 = claim_space(div1_nodes);
			img = claim_element(div1_nodes, "IMG", { class: true, src: true, alt: true });
			t4 = claim_space(div1_nodes);
			div0 = claim_element(div1_nodes, "DIV", { class: true });
			var div0_nodes = children(div0);
			t5 = claim_text(div0_nodes, "Choose Image");
			div0_nodes.forEach(detach_dev);
			t6 = claim_space(div1_nodes);
			input = claim_element(div1_nodes, "INPUT", { style: true, type: true, accept: true });
			div1_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(h4, file$2, 42, 1, 914);
			attr_dev(img, "class", "upload svelte-16mpme9");
			if (!src_url_equal(img.src, img_src_value = "https://static.thenounproject.com/png/625182-200.png")) attr_dev(img, "src", img_src_value);
			attr_dev(img, "alt", "");
			add_location(img, file$2, 49, 4, 1125);
			attr_dev(div0, "class", "chan");
			add_location(div0, file$2, 50, 8, 1258);
			set_style(input, "display", "none");
			attr_dev(input, "type", "file");
			attr_dev(input, "accept", ".jpg, .jpeg, .png");
			add_location(input, file$2, 51, 8, 1339);
			attr_dev(div1, "id", "app");
			attr_dev(div1, "class", "svelte-16mpme9");
			add_location(div1, file$2, 41, 0, 898);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, div1, anchor);
			append_hydration_dev(div1, h4);
			append_hydration_dev(h4, t0);
			append_hydration_dev(h4, t1);
			append_hydration_dev(div1, t2);
			if_block.m(div1, null);
			append_hydration_dev(div1, t3);
			append_hydration_dev(div1, img);
			append_hydration_dev(div1, t4);
			append_hydration_dev(div1, div0);
			append_hydration_dev(div0, t5);
			append_hydration_dev(div1, t6);
			append_hydration_dev(div1, input);
			/*input_binding*/ ctx[7](input);

			if (!mounted) {
				dispose = [
					listen_dev(img, "click", /*click_handler*/ ctx[4], false, false, false),
					listen_dev(div0, "click", /*click_handler_1*/ ctx[5], false, false, false),
					listen_dev(input, "change", /*change_handler*/ ctx[6], false, false, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*name*/ 2) set_data_dev(t0, /*name*/ ctx[1]);

			if (current_block_type === (current_block_type = select_block_type(ctx)) && if_block) {
				if_block.p(ctx, dirty);
			} else {
				if_block.d(1);
				if_block = current_block_type(ctx);

				if (if_block) {
					if_block.c();
					if_block.m(div1, t3);
				}
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div1);
			if_block.d();
			/*input_binding*/ ctx[7](null);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$2.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$2($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('ImageUpload', slots, []);
	let { avatar } = $$props, { name } = $$props;
	console.log("avatar" + avatar);
	let fileinput;
	var formData = new browser();

	const onFileSelected = async e => {
		let image = e.target.files[0];

		//fetch upload of the image as the logo of the company!
		formData.append(name, image);

		const options = { method: 'POST', body: formData }; // If you add this, upload won't work
		// headers: {
		//   'Content-Type': 'multipart/form-data',

		// }
		var res = await fetch(`/utils/${name}ImageUpload.json`, options);

		if (res.status == 200) {
			let reader = new FileReader();
			reader.readAsDataURL(image);

			reader.onload = e => {
				$$invalidate(0, avatar = e.target.result);
			};
		} else {
			let text = await res.text();
			text = JSON.parse(text);
			alert(text.message);
		}
	};

	const writable_props = ['avatar', 'name'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$2.warn(`<ImageUpload> was created with unknown prop '${key}'`);
	});

	const click_handler = () => {
		fileinput.click();
	};

	const click_handler_1 = () => {
		fileinput.click();
	};

	const change_handler = e => onFileSelected(e);

	function input_binding($$value) {
		binding_callbacks[$$value ? 'unshift' : 'push'](() => {
			fileinput = $$value;
			$$invalidate(2, fileinput);
		});
	}

	$$self.$$set = $$props => {
		if ('avatar' in $$props) $$invalidate(0, avatar = $$props.avatar);
		if ('name' in $$props) $$invalidate(1, name = $$props.name);
	};

	$$self.$capture_state = () => ({
		avatar,
		name,
		fileinput,
		FormData: browser,
		formData,
		onFileSelected
	});

	$$self.$inject_state = $$props => {
		if ('avatar' in $$props) $$invalidate(0, avatar = $$props.avatar);
		if ('name' in $$props) $$invalidate(1, name = $$props.name);
		if ('fileinput' in $$props) $$invalidate(2, fileinput = $$props.fileinput);
		if ('formData' in $$props) formData = $$props.formData;
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		avatar,
		name,
		fileinput,
		onFileSelected,
		click_handler,
		click_handler_1,
		change_handler,
		input_binding
	];
}

class ImageUpload extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$2, create_fragment$2, safe_not_equal, { avatar: 0, name: 1 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "ImageUpload",
			options,
			id: create_fragment$2.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*avatar*/ ctx[0] === undefined && !('avatar' in props)) {
			console_1$2.warn("<ImageUpload> was created without expected prop 'avatar'");
		}

		if (/*name*/ ctx[1] === undefined && !('name' in props)) {
			console_1$2.warn("<ImageUpload> was created without expected prop 'name'");
		}
	}

	get avatar() {
		throw new Error("<ImageUpload>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set avatar(value) {
		throw new Error("<ImageUpload>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get name() {
		throw new Error("<ImageUpload>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set name(value) {
		throw new Error("<ImageUpload>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/routes/_utils/dataUpload.svelte generated by Svelte v3.40.2 */

const { console: console_1$1 } = globals;
const file$1 = "src/routes/_utils/dataUpload.svelte";

function create_fragment$1(ctx) {
	let div;
	let form;
	let h60;
	let t0;
	let input0;
	let t1;
	let h61;
	let t2;
	let input1;
	let t3;
	let h62;
	let t4;
	let input2;
	let t5;
	let input3;
	let mounted;
	let dispose;

	const block = {
		c: function create() {
			div = element("div");
			form = element("form");
			h60 = element("h6");
			t0 = text("Name");
			input0 = element("input");
			t1 = space();
			h61 = element("h6");
			t2 = text("Organization");
			input1 = element("input");
			t3 = space();
			h62 = element("h6");
			t4 = text("Post");
			input2 = element("input");
			t5 = space();
			input3 = element("input");
			this.h();
		},
		l: function claim(nodes) {
			div = claim_element(nodes, "DIV", { id: true, class: true });
			var div_nodes = children(div);
			form = claim_element(div_nodes, "FORM", {});
			var form_nodes = children(form);
			h60 = claim_element(form_nodes, "H6", {});
			var h60_nodes = children(h60);
			t0 = claim_text(h60_nodes, "Name");
			h60_nodes.forEach(detach_dev);

			input0 = claim_element(form_nodes, "INPUT", {
				type: true,
				name: true,
				placeholder: true
			});

			t1 = claim_space(form_nodes);
			h61 = claim_element(form_nodes, "H6", {});
			var h61_nodes = children(h61);
			t2 = claim_text(h61_nodes, "Organization");
			h61_nodes.forEach(detach_dev);

			input1 = claim_element(form_nodes, "INPUT", {
				type: true,
				name: true,
				placeholder: true
			});

			t3 = claim_space(form_nodes);
			h62 = claim_element(form_nodes, "H6", {});
			var h62_nodes = children(h62);
			t4 = claim_text(h62_nodes, "Post");
			h62_nodes.forEach(detach_dev);

			input2 = claim_element(form_nodes, "INPUT", {
				type: true,
				name: true,
				placeholder: true
			});

			t5 = claim_space(form_nodes);
			input3 = claim_element(form_nodes, "INPUT", { type: true });
			form_nodes.forEach(detach_dev);
			div_nodes.forEach(detach_dev);
			this.h();
		},
		h: function hydrate() {
			add_location(h60, file$1, 54, 2, 900);
			attr_dev(input0, "type", "text");
			attr_dev(input0, "name", "name");
			attr_dev(input0, "placeholder", /*name*/ ctx[1]);
			add_location(input0, file$1, 54, 15, 913);
			add_location(h61, file$1, 55, 2, 986);
			attr_dev(input1, "type", "text");
			attr_dev(input1, "name", "organization");
			attr_dev(input1, "placeholder", /*organization*/ ctx[0]);
			add_location(input1, file$1, 55, 23, 1007);
			add_location(h62, file$1, 56, 2, 1104);
			attr_dev(input2, "type", "text");
			attr_dev(input2, "name", "post");
			attr_dev(input2, "placeholder", /*post*/ ctx[2]);
			add_location(input2, file$1, 56, 15, 1117);
			attr_dev(input3, "type", "submit");
			input3.value = "Save";
			add_location(input3, file$1, 58, 2, 1192);
			add_location(form, file$1, 52, 1, 851);
			attr_dev(div, "id", "app");
			attr_dev(div, "class", "svelte-16mpme9");
			add_location(div, file$1, 51, 0, 835);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, div, anchor);
			append_hydration_dev(div, form);
			append_hydration_dev(form, h60);
			append_hydration_dev(h60, t0);
			append_hydration_dev(form, input0);
			set_input_value(input0, /*name*/ ctx[1]);
			append_hydration_dev(form, t1);
			append_hydration_dev(form, h61);
			append_hydration_dev(h61, t2);
			append_hydration_dev(form, input1);
			set_input_value(input1, /*organization*/ ctx[0]);
			append_hydration_dev(form, t3);
			append_hydration_dev(form, h62);
			append_hydration_dev(h62, t4);
			append_hydration_dev(form, input2);
			set_input_value(input2, /*post*/ ctx[2]);
			append_hydration_dev(form, t5);
			append_hydration_dev(form, input3);

			if (!mounted) {
				dispose = [
					listen_dev(input0, "input", /*input0_input_handler*/ ctx[4]),
					listen_dev(input1, "input", /*input1_input_handler*/ ctx[5]),
					listen_dev(input2, "input", /*input2_input_handler*/ ctx[6]),
					listen_dev(form, "submit", prevent_default(/*updateInfo*/ ctx[3]), false, true, false)
				];

				mounted = true;
			}
		},
		p: function update(ctx, [dirty]) {
			if (dirty & /*name*/ 2) {
				attr_dev(input0, "placeholder", /*name*/ ctx[1]);
			}

			if (dirty & /*name*/ 2 && input0.value !== /*name*/ ctx[1]) {
				set_input_value(input0, /*name*/ ctx[1]);
			}

			if (dirty & /*organization*/ 1) {
				attr_dev(input1, "placeholder", /*organization*/ ctx[0]);
			}

			if (dirty & /*organization*/ 1 && input1.value !== /*organization*/ ctx[0]) {
				set_input_value(input1, /*organization*/ ctx[0]);
			}

			if (dirty & /*post*/ 4) {
				attr_dev(input2, "placeholder", /*post*/ ctx[2]);
			}

			if (dirty & /*post*/ 4 && input2.value !== /*post*/ ctx[2]) {
				set_input_value(input2, /*post*/ ctx[2]);
			}
		},
		i: noop,
		o: noop,
		d: function destroy(detaching) {
			if (detaching) detach_dev(div);
			mounted = false;
			run_all(dispose);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment$1.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

function instance$1($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('DataUpload', slots, []);

	let { organization = "organization" } = $$props,
		{ name = "name" } = $$props,
		{ post = "post" } = $$props;

	async function updateInfo() {
		var body = { organization, name, post };
		console.log(body);

		const options = {
			mode: "cors",
			headers: { "Content-Type": "application/json" },
			method: 'POST',
			body: JSON.stringify(body)
		};

		var res = await fetch(`/utils/infoUpload.json`, options);

		if (res.status == 200) ; else // reset the input fields with placeholders
		{
			let text = await res.text(); //successfullt updated
			text = JSON.parse(text);
			alert(text.message);
		}
	}

	const writable_props = ['organization', 'name', 'post'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1$1.warn(`<DataUpload> was created with unknown prop '${key}'`);
	});

	function input0_input_handler() {
		name = this.value;
		$$invalidate(1, name);
	}

	function input1_input_handler() {
		organization = this.value;
		$$invalidate(0, organization);
	}

	function input2_input_handler() {
		post = this.value;
		$$invalidate(2, post);
	}

	$$self.$$set = $$props => {
		if ('organization' in $$props) $$invalidate(0, organization = $$props.organization);
		if ('name' in $$props) $$invalidate(1, name = $$props.name);
		if ('post' in $$props) $$invalidate(2, post = $$props.post);
	};

	$$self.$capture_state = () => ({ organization, name, post, updateInfo });

	$$self.$inject_state = $$props => {
		if ('organization' in $$props) $$invalidate(0, organization = $$props.organization);
		if ('name' in $$props) $$invalidate(1, name = $$props.name);
		if ('post' in $$props) $$invalidate(2, post = $$props.post);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [
		organization,
		name,
		post,
		updateInfo,
		input0_input_handler,
		input1_input_handler,
		input2_input_handler
	];
}

class DataUpload extends SvelteComponentDev {
	constructor(options) {
		super(options);
		init(this, options, instance$1, create_fragment$1, safe_not_equal, { organization: 0, name: 1, post: 2 });

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "DataUpload",
			options,
			id: create_fragment$1.name
		});
	}

	get organization() {
		throw new Error("<DataUpload>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set organization(value) {
		throw new Error("<DataUpload>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get name() {
		throw new Error("<DataUpload>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set name(value) {
		throw new Error("<DataUpload>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get post() {
		throw new Error("<DataUpload>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set post(value) {
		throw new Error("<DataUpload>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

/* src/routes/dashboard/index.svelte generated by Svelte v3.40.2 */

const { console: console_1 } = globals;
const file = "src/routes/dashboard/index.svelte";

function create_fragment(ctx) {
	let t0;
	let h1;
	let t1;
	let t2;
	let p;
	let t3;
	let a;
	let t4;
	let t5;
	let hr0;
	let t6;
	let div;
	let dataupload;
	let t7;
	let imageupload0;
	let t8;
	let imageupload1;
	let t9;
	let hr1;
	let current;

	dataupload = new DataUpload({
			props: {
				class: "flex",
				organization: /*user*/ ctx[0].organization,
				post: /*user*/ ctx[0].post,
				name: /*user*/ ctx[0].name
			},
			$$inline: true
		});

	imageupload0 = new ImageUpload({
			props: {
				class: "flex",
				avatar: /*user*/ ctx[0].logo,
				name: "logo"
			},
			$$inline: true
		});

	imageupload1 = new ImageUpload({
			props: {
				class: "flex",
				avatar: /*user*/ ctx[0].signature,
				name: "signature"
			},
			$$inline: true
		});

	const block = {
		c: function create() {
			t0 = space();
			h1 = element("h1");
			t1 = text("Great!");
			t2 = space();
			p = element("p");
			t3 = text("Go ahead and create a ");
			a = element("a");
			t4 = text("new certificate!");
			t5 = text("\nMake sure that these images are uploaded...\n");
			hr0 = element("hr");
			t6 = space();
			div = element("div");
			create_component(dataupload.$$.fragment);
			t7 = space();
			create_component(imageupload0.$$.fragment);
			t8 = space();
			create_component(imageupload1.$$.fragment);
			t9 = space();
			hr1 = element("hr");
			this.h();
		},
		l: function claim(nodes) {
			const head_nodes = query_selector_all('[data-svelte=\"svelte-oh6yg0\"]', document.head);
			head_nodes.forEach(detach_dev);
			t0 = claim_space(nodes);
			h1 = claim_element(nodes, "H1", { class: true });
			var h1_nodes = children(h1);
			t1 = claim_text(h1_nodes, "Great!");
			h1_nodes.forEach(detach_dev);
			t2 = claim_space(nodes);
			p = claim_element(nodes, "P", { class: true });
			var p_nodes = children(p);
			t3 = claim_text(p_nodes, "Go ahead and create a ");
			a = claim_element(p_nodes, "A", { href: true });
			var a_nodes = children(a);
			t4 = claim_text(a_nodes, "new certificate!");
			a_nodes.forEach(detach_dev);
			p_nodes.forEach(detach_dev);
			t5 = claim_text(nodes, "\nMake sure that these images are uploaded...\n");
			hr0 = claim_element(nodes, "HR", {});
			t6 = claim_space(nodes);
			div = claim_element(nodes, "DIV", { style: true });
			var div_nodes = children(div);
			claim_component(dataupload.$$.fragment, div_nodes);
			t7 = claim_space(div_nodes);
			claim_component(imageupload0.$$.fragment, div_nodes);
			t8 = claim_space(div_nodes);
			claim_component(imageupload1.$$.fragment, div_nodes);
			div_nodes.forEach(detach_dev);
			t9 = claim_space(nodes);
			hr1 = claim_element(nodes, "HR", {});
			this.h();
		},
		h: function hydrate() {
			document.title = "Sapper project template";
			attr_dev(h1, "class", "svelte-1w21azg");
			add_location(h1, file, 89, 0, 1460);
			attr_dev(a, "href", "/create_certificate");
			add_location(a, file, 90, 25, 1501);
			attr_dev(p, "class", "svelte-1w21azg");
			add_location(p, file, 90, 0, 1476);
			add_location(hr0, file, 92, 0, 1600);
			set_style(div, "display", "flex");
			set_style(div, "width", "100%");
			add_location(div, file, 95, 1, 1608);
			add_location(hr1, file, 100, 0, 1887);
		},
		m: function mount(target, anchor) {
			insert_hydration_dev(target, t0, anchor);
			insert_hydration_dev(target, h1, anchor);
			append_hydration_dev(h1, t1);
			insert_hydration_dev(target, t2, anchor);
			insert_hydration_dev(target, p, anchor);
			append_hydration_dev(p, t3);
			append_hydration_dev(p, a);
			append_hydration_dev(a, t4);
			insert_hydration_dev(target, t5, anchor);
			insert_hydration_dev(target, hr0, anchor);
			insert_hydration_dev(target, t6, anchor);
			insert_hydration_dev(target, div, anchor);
			mount_component(dataupload, div, null);
			append_hydration_dev(div, t7);
			mount_component(imageupload0, div, null);
			append_hydration_dev(div, t8);
			mount_component(imageupload1, div, null);
			insert_hydration_dev(target, t9, anchor);
			insert_hydration_dev(target, hr1, anchor);
			current = true;
		},
		p: function update(ctx, [dirty]) {
			const dataupload_changes = {};
			if (dirty & /*user*/ 1) dataupload_changes.organization = /*user*/ ctx[0].organization;
			if (dirty & /*user*/ 1) dataupload_changes.post = /*user*/ ctx[0].post;
			if (dirty & /*user*/ 1) dataupload_changes.name = /*user*/ ctx[0].name;
			dataupload.$set(dataupload_changes);
			const imageupload0_changes = {};
			if (dirty & /*user*/ 1) imageupload0_changes.avatar = /*user*/ ctx[0].logo;
			imageupload0.$set(imageupload0_changes);
			const imageupload1_changes = {};
			if (dirty & /*user*/ 1) imageupload1_changes.avatar = /*user*/ ctx[0].signature;
			imageupload1.$set(imageupload1_changes);
		},
		i: function intro(local) {
			if (current) return;
			transition_in(dataupload.$$.fragment, local);
			transition_in(imageupload0.$$.fragment, local);
			transition_in(imageupload1.$$.fragment, local);
			current = true;
		},
		o: function outro(local) {
			transition_out(dataupload.$$.fragment, local);
			transition_out(imageupload0.$$.fragment, local);
			transition_out(imageupload1.$$.fragment, local);
			current = false;
		},
		d: function destroy(detaching) {
			if (detaching) detach_dev(t0);
			if (detaching) detach_dev(h1);
			if (detaching) detach_dev(t2);
			if (detaching) detach_dev(p);
			if (detaching) detach_dev(t5);
			if (detaching) detach_dev(hr0);
			if (detaching) detach_dev(t6);
			if (detaching) detach_dev(div);
			destroy_component(dataupload);
			destroy_component(imageupload0);
			destroy_component(imageupload1);
			if (detaching) detach_dev(t9);
			if (detaching) detach_dev(hr1);
		}
	};

	dispatch_dev("SvelteRegisterBlock", {
		block,
		id: create_fragment.name,
		type: "component",
		source: "",
		ctx
	});

	return block;
}

var certificates = {};

const preload = async function (page, session) {
	var { user } = session;

	// user=JSON.parse(user);
	if (!user) {
		return this.redirect(301, 'login');
	}

	console.log(user);
	const res = await this.fetch('dashboard.json', { mode: 'cors', method: 'get' });

	if (res.status == 200) {
		var data = await res.json();
		console.log(data);

		if (data.status == "success") {
			certificates = data.data;
			console.log(certificates);
		} else {
			this.error(data.status, data.message);
		}
	} // let data = JSON.parse(text);

	console.log(1);
	user = JSON.parse(user);
	return { user, certificates };
};

function instance($$self, $$props, $$invalidate) {
	let { $$slots: slots = {}, $$scope } = $$props;
	validate_slots('Dashboard', slots, []);
	let { email } = $$props, { password } = $$props;
	let { user } = $$props;
	let { certificates } = $$props;
	const writable_props = ['email', 'password', 'user', 'certificates'];

	Object.keys($$props).forEach(key => {
		if (!~writable_props.indexOf(key) && key.slice(0, 2) !== '$$' && key !== 'slot') console_1.warn(`<Dashboard> was created with unknown prop '${key}'`);
	});

	$$self.$$set = $$props => {
		if ('email' in $$props) $$invalidate(1, email = $$props.email);
		if ('password' in $$props) $$invalidate(2, password = $$props.password);
		if ('user' in $$props) $$invalidate(0, user = $$props.user);
		if ('certificates' in $$props) $$invalidate(3, certificates = $$props.certificates);
	};

	$$self.$capture_state = () => ({
		certificates,
		preload,
		ImageUpload,
		DataUpload,
		email,
		password,
		user,
		certificates,
		successkid
	});

	$$self.$inject_state = $$props => {
		if ('email' in $$props) $$invalidate(1, email = $$props.email);
		if ('password' in $$props) $$invalidate(2, password = $$props.password);
		if ('user' in $$props) $$invalidate(0, user = $$props.user);
		if ('certificates' in $$props) $$invalidate(3, certificates = $$props.certificates);
	};

	if ($$props && "$$inject" in $$props) {
		$$self.$inject_state($$props.$$inject);
	}

	return [user, email, password, certificates];
}

class Dashboard extends SvelteComponentDev {
	constructor(options) {
		super(options);

		init(this, options, instance, create_fragment, safe_not_equal, {
			email: 1,
			password: 2,
			user: 0,
			certificates: 3
		});

		dispatch_dev("SvelteRegisterComponent", {
			component: this,
			tagName: "Dashboard",
			options,
			id: create_fragment.name
		});

		const { ctx } = this.$$;
		const props = options.props || {};

		if (/*email*/ ctx[1] === undefined && !('email' in props)) {
			console_1.warn("<Dashboard> was created without expected prop 'email'");
		}

		if (/*password*/ ctx[2] === undefined && !('password' in props)) {
			console_1.warn("<Dashboard> was created without expected prop 'password'");
		}

		if (/*user*/ ctx[0] === undefined && !('user' in props)) {
			console_1.warn("<Dashboard> was created without expected prop 'user'");
		}

		if (/*certificates*/ ctx[3] === undefined && !('certificates' in props)) {
			console_1.warn("<Dashboard> was created without expected prop 'certificates'");
		}
	}

	get email() {
		throw new Error("<Dashboard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set email(value) {
		throw new Error("<Dashboard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get password() {
		throw new Error("<Dashboard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set password(value) {
		throw new Error("<Dashboard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get user() {
		throw new Error("<Dashboard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set user(value) {
		throw new Error("<Dashboard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	get certificates() {
		throw new Error("<Dashboard>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}

	set certificates(value) {
		throw new Error("<Dashboard>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
	}
}

export default Dashboard;
export { preload };
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguZWRiZGU5NmEuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uL25vZGVfbW9kdWxlcy9mb3JtLWRhdGEvbGliL2Jyb3dzZXIuanMiLCIuLi8uLi8uLi9zcmMvcm91dGVzL191dGlscy9pbWFnZVVwbG9hZC5zdmVsdGUiLCIuLi8uLi8uLi9zcmMvcm91dGVzL191dGlscy9kYXRhVXBsb2FkLnN2ZWx0ZSIsIi4uLy4uLy4uL3NyYy9yb3V0ZXMvZGFzaGJvYXJkL2luZGV4LnN2ZWx0ZSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cbm1vZHVsZS5leHBvcnRzID0gdHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgPyBzZWxmLkZvcm1EYXRhIDogd2luZG93LkZvcm1EYXRhO1xuIiwiPHNjcmlwdD5cblx0ZXhwb3J0IGxldCBhdmF0YXIsIG5hbWU7XG5cdGNvbnNvbGUubG9nKFwiYXZhdGFyXCIrYXZhdGFyKTtcblx0bGV0IGZpbGVpbnB1dDtcblx0aW1wb3J0IEZvcm1EYXRhIGZyb20gJ2Zvcm0tZGF0YSc7XG5cdHZhciBmb3JtRGF0YSA9IG5ldyBGb3JtRGF0YSgpO1xuXHRcblx0Y29uc3Qgb25GaWxlU2VsZWN0ZWQgPWFzeW5jIChlKSA9PntcbiAgbGV0IGltYWdlID0gZS50YXJnZXQuZmlsZXNbMF07XG4gIC8vZmV0Y2ggdXBsb2FkIG9mIHRoZSBpbWFnZSBhcyB0aGUgbG9nbyBvZiB0aGUgY29tcGFueSFcbiAgZm9ybURhdGEuYXBwZW5kKG5hbWUsIGltYWdlKTtcblxuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICBtZXRob2Q6ICdQT1NUJyxcbiAgICAgIGJvZHk6IGZvcm1EYXRhLFxuICAgICAgLy8gSWYgeW91IGFkZCB0aGlzLCB1cGxvYWQgd29uJ3Qgd29ya1xuICAgICAgLy8gaGVhZGVyczoge1xuICAgICAgLy8gICAnQ29udGVudC1UeXBlJzogJ211bHRpcGFydC9mb3JtLWRhdGEnLFxuICAgICAgLy8gfVxuICAgIH07XG4gICAgXG4gICAgdmFyIHJlcyA9IGF3YWl0IGZldGNoKGAvdXRpbHMvJHtuYW1lfUltYWdlVXBsb2FkLmpzb25gLCBvcHRpb25zKTtcblx0aWYocmVzLnN0YXR1cz09MjAwKVxuXHR7XG5cdFx0bGV0IHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICAgICAgICByZWFkZXIucmVhZEFzRGF0YVVSTChpbWFnZSk7XG4gICAgICAgICAgICByZWFkZXIub25sb2FkID0gZSA9PiB7XG4gICAgICAgICAgICAgICAgIGF2YXRhciA9IGUudGFyZ2V0LnJlc3VsdFxuICAgICAgICAgICAgfTtcblx0fVxuXHRlbHNle1xuXHRcdGxldCB0ZXh0ID0gYXdhaXQgcmVzLnRleHQoKTtcblx0XHR0ZXh0ID0gSlNPTi5wYXJzZSh0ZXh0KTtcblx0XHRhbGVydCh0ZXh0Lm1lc3NhZ2UpO1xuXHR9XG5cblxuICAgICAgICAgICAgXG59XG5cdFxuPC9zY3JpcHQ+XG48ZGl2IGlkPVwiYXBwXCI+XG5cdDxoND57bmFtZX0gZm9yIHRoZSBjZXJ0aWZpY2F0ZXM8L2g0PlxuICBcbiAgICAgICAgeyNpZiBhdmF0YXJ9XG4gICAgICAgIDxpbWcgY2xhc3M9XCJhdmF0YXJcIiBzcmM9XCJ7YXZhdGFyfVwiIGFsdD1cIlwiIC8+XG4gICAgICAgIHs6ZWxzZX1cbiAgICAgICAgPGltZyBjbGFzcz1cImF2YXRhclwiIHNyYz1cIi9pbWFnZXMvYmxhbmsuanBnXCIgYWx0PVwiXCIgLz4gXG4gICAgICAgIHsvaWZ9XG5cdFx0XHRcdDxpbWcgY2xhc3M9XCJ1cGxvYWRcIiBzcmM9XCJodHRwczovL3N0YXRpYy50aGVub3VucHJvamVjdC5jb20vcG5nLzYyNTE4Mi0yMDAucG5nXCIgYWx0PVwiXCIgb246Y2xpY2s9eygpPT57ZmlsZWlucHV0LmNsaWNrKCk7fX0gLz5cbiAgICAgICAgPGRpdiBjbGFzcz1cImNoYW5cIiBvbjpjbGljaz17KCk9PntmaWxlaW5wdXQuY2xpY2soKTt9fT5DaG9vc2UgSW1hZ2U8L2Rpdj5cbiAgICAgICAgPGlucHV0IHN0eWxlPVwiZGlzcGxheTpub25lXCIgdHlwZT1cImZpbGVcIiBhY2NlcHQ9XCIuanBnLCAuanBlZywgLnBuZ1wiIG9uOmNoYW5nZT17KGUpPT5vbkZpbGVTZWxlY3RlZChlKX0gYmluZDp0aGlzPXtmaWxlaW5wdXR9ID5cblxuPC9kaXY+XG48c3R5bGU+XG5cdCNhcHB7XG5cdGRpc3BsYXk6ZmxleDtcblx0XHRhbGlnbi1pdGVtczpjZW50ZXI7XG5cdFx0anVzdGlmeS1jb250ZW50OmNlbnRlcjtcblx0XHRmbGV4LWZsb3c6Y29sdW1uO1xufVxuIFxuXHQudXBsb2Fke1xuXHRcdGRpc3BsYXk6ZmxleDtcblx0aGVpZ2h0OjUwcHg7XG5cdFx0d2lkdGg6NTBweDtcblx0XHRjdXJzb3I6cG9pbnRlcjtcblx0fVxuXHQuYXZhdGFye1xuXHRcdGRpc3BsYXk6ZmxleDtcblx0XHRoZWlnaHQ6MjAwcHg7XG5cdFx0d2lkdGg6MjAwcHg7XG5cdH1cbjwvc3R5bGU+XG5cbiAiLCI8c2NyaXB0PlxuXHRleHBvcnQgbGV0IG9yZ2FuaXphdGlvbj1cIm9yZ2FuaXphdGlvblwiLCBuYW1lPVwibmFtZVwiICxwb3N0PVwicG9zdFwiO1xuXG5cdGFzeW5jIGZ1bmN0aW9uIHVwZGF0ZUluZm8oKXtcblx0XHR2YXIgYm9keSA9IHtvcmdhbml6YXRpb24sbmFtZSxwb3N0fTtcblx0XHRjb25zb2xlLmxvZyhib2R5KTtcblx0XHRjb25zdCBvcHRpb25zID0ge1xuXHRcdFx0bW9kZTpcImNvcnNcIixcblx0XHRcdGhlYWRlcnM6e1wiQ29udGVudC1UeXBlXCI6XCJhcHBsaWNhdGlvbi9qc29uXCJ9LFxuICAgICAgbWV0aG9kOiAnUE9TVCcsXG4gICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShib2R5KSxcbiAgICB9O1xuICAgIFxuICAgIHZhciByZXMgPSBhd2FpdCBmZXRjaChgL3V0aWxzL2luZm9VcGxvYWQuanNvbmAsIG9wdGlvbnMpO1xuXHRpZihyZXMuc3RhdHVzPT0yMDApXG5cdHtcblx0XHQvL3N1Y2Nlc3NmdWxsdCB1cGRhdGVkXG5cdFx0Ly8gcmVzZXQgdGhlIGlucHV0IGZpZWxkcyB3aXRoIHBsYWNlaG9sZGVyc1xuXHR9XG5cdGVsc2V7XG5cdFx0bGV0IHRleHQgPSBhd2FpdCByZXMudGV4dCgpO1xuXHRcdHRleHQgPSBKU09OLnBhcnNlKHRleHQpO1xuXHRcdGFsZXJ0KHRleHQubWVzc2FnZSk7XG5cdH1cbn1cblx0XG5cdFxuPC9zY3JpcHQ+XG5cbjxzdHlsZT5cblx0I2FwcHtcblx0ZGlzcGxheTpmbGV4O1xuXHRcdGFsaWduLWl0ZW1zOmNlbnRlcjtcblx0XHRqdXN0aWZ5LWNvbnRlbnQ6Y2VudGVyO1xuXHRcdGZsZXgtZmxvdzpjb2x1bW47XG59XG4gXG5cdC51cGxvYWR7XG5cdFx0ZGlzcGxheTpmbGV4O1xuXHRoZWlnaHQ6NTBweDtcblx0XHR3aWR0aDo1MHB4O1xuXHRcdGN1cnNvcjpwb2ludGVyO1xuXHR9XG5cdC5hdmF0YXJ7XG5cdFx0ZGlzcGxheTpmbGV4O1xuXHRcdGhlaWdodDoyMDBweDtcblx0XHR3aWR0aDoyMDBweDtcblx0fVxuPC9zdHlsZT5cblxuXG48ZGl2IGlkPVwiYXBwXCI+XG5cdDxmb3JtIG9uOnN1Ym1pdHxwcmV2ZW50RGVmYXVsdD17dXBkYXRlSW5mb30gPlxuXG5cdFx0PGg2Pk5hbWU8L2g2PjxpbnB1dCB0eXBlPVwidGV4dFwiIGJpbmQ6dmFsdWU9e25hbWV9IG5hbWU9XCJuYW1lXCIgcGxhY2Vob2xkZXI9e25hbWV9IC8+XG5cdFx0PGg2Pk9yZ2FuaXphdGlvbjwvaDY+PGlucHV0IHR5cGU9XCJ0ZXh0XCIgYmluZDp2YWx1ZT17b3JnYW5pemF0aW9ufSBuYW1lPVwib3JnYW5pemF0aW9uXCIgcGxhY2Vob2xkZXI9e29yZ2FuaXphdGlvbn0gLz5cblx0XHQ8aDY+UG9zdDwvaDY+PGlucHV0IHR5cGU9XCJ0ZXh0XCIgYmluZDp2YWx1ZT17cG9zdH0gbmFtZT1cInBvc3RcIiBwbGFjZWhvbGRlcj17cG9zdH0gLz5cblx0XG5cdFx0PGlucHV0IHR5cGU9XCJzdWJtaXRcIiB2YWx1ZT1cIlNhdmVcIiA+XG5cdFxuXHQ8L2Zvcm0+XG48L2Rpdj5cblxuXG4gIiwiPHNjcmlwdCBjb250ZXh0PVwibW9kdWxlXCI+XG5cdHZhciBjZXJ0aWZpY2F0ZXMgPXt9O1xuXHQvLyBpbXBvcnQgeyBQcmVsb2FkIH0gZnJvbSBcIkBzYXBwZXIvY29tbW9uXCI7XG5cblx0ZXhwb3J0IGNvbnN0IHByZWxvYWQgPSBhc3luYyBmdW5jdGlvbiggcGFnZSwgc2Vzc2lvbikge1xuXHRcdHZhciB7IHVzZXIgfSA9IHNlc3Npb247XG5cdFx0Ly8gdXNlcj1KU09OLnBhcnNlKHVzZXIpO1xuXHRcdGlmKCF1c2VyKVxuXHRcdHtcblx0XHRcdHJldHVybiB0aGlzLnJlZGlyZWN0KDMwMSwgJ2xvZ2luJyk7XG5cdFx0fVxuXHRcdGNvbnNvbGUubG9nKHVzZXIpO1xuXG5cdFx0Y29uc3QgcmVzID0gYXdhaXQgdGhpcy5mZXRjaCgnZGFzaGJvYXJkLmpzb24nLHttb2RlOidjb3JzJyxtZXRob2Q6J2dldCd9KTtcblx0XHRpZihyZXMuc3RhdHVzPT0yMDApe1xuXHRcdFx0dmFyIGRhdGEgPSBhd2FpdCByZXMuanNvbigpO1xuXHRcdFx0Y29uc29sZS5sb2coZGF0YSk7XG5cdFx0XHRpZihkYXRhLnN0YXR1cyA9PSBcInN1Y2Nlc3NcIilcblx0XHRcdHtcblx0XHRcdFx0Y2VydGlmaWNhdGVzID0gZGF0YS5kYXRhO1xuXHRcdFx0XHRjb25zb2xlLmxvZyhjZXJ0aWZpY2F0ZXMpO1xuXHRcdFx0XHRcblx0XHRcdH1cblx0XHRcdGVsc2V7XG5cdFx0XHRcdHRoaXMuZXJyb3IoZGF0YS5zdGF0dXMsZGF0YS5tZXNzYWdlKTtcblx0XHRcdH1cblx0XHRcdC8vIGxldCBkYXRhID0gSlNPTi5wYXJzZSh0ZXh0KTtcblx0XHRcdFxuXHRcdH1cblx0XHRjb25zb2xlLmxvZygxKTtcblx0XHR1c2VyPUpTT04ucGFyc2UodXNlcik7XG5cdFx0cmV0dXJuIHsgdXNlciwgY2VydGlmaWNhdGVzIH07XG5cdH1cblxuXG5cdFxuPC9zY3JpcHQ+XG5cbjxzY3JpcHQ+XG5cdGltcG9ydCBJbWFnZVVwbG9hZCBmcm9tICcuLi9fdXRpbHMvaW1hZ2VVcGxvYWQuc3ZlbHRlJztcblx0aW1wb3J0IERhdGFVcGxvYWQgZnJvbSAnLi4vX3V0aWxzL2RhdGFVcGxvYWQuc3ZlbHRlJztcblx0ZXhwb3J0IGxldCBlbWFpbCxwYXNzd29yZDtcblx0ZXhwb3J0IGxldCB1c2VyO1xuXHRleHBvcnQgbGV0IGNlcnRpZmljYXRlcztcblx0aW1wb3J0IHN1Y2Nlc3NraWQgZnJvbSAnaW1hZ2VzL3N1Y2Nlc3NraWQuanBnJztcblxuPC9zY3JpcHQ+XG5cbjxzdHlsZT5cblx0aDEsIGZpZ3VyZSwgcCB7XG5cdFx0dGV4dC1hbGlnbjogbGVmdDtcblx0XHRtYXJnaW46IDAgYXV0bztcblx0fVxuXG5cdGgxIHtcblx0XHRmb250LXNpemU6IDIuOGVtO1xuXHRcdHRleHQtdHJhbnNmb3JtOiB1cHBlcmNhc2U7XG5cdFx0Zm9udC13ZWlnaHQ6IDcwMDtcblx0XHRtYXJnaW46IDAgMCAwLjVlbSAwO1xuXHR9XG5cblx0ZmlndXJlIHtcblx0XHRtYXJnaW46IDAgMCAxZW0gMDtcblx0fVxuXG5cdGltZyB7XG5cdFx0d2lkdGg6IDEwMCU7XG5cdFx0bWF4LXdpZHRoOiA0MDBweDtcblx0XHRtYXJnaW46IDAgMCAxZW0gMDtcblx0fVxuXG5cdHAge1xuXHRcdG1hcmdpbjogMWVtIGF1dG87XG5cdH1cblxuXHRAbWVkaWEgKG1pbi13aWR0aDogNDgwcHgpIHtcblx0XHRoMSB7XG5cdFx0XHRmb250LXNpemU6IDRlbTtcblx0XHR9XG5cdH1cblx0LmZsZXh7XG5cdFx0ZmxleDoxO1xuXHR9XG48L3N0eWxlPlxuXG48c3ZlbHRlOmhlYWQ+XG5cdDx0aXRsZT5TYXBwZXIgcHJvamVjdCB0ZW1wbGF0ZTwvdGl0bGU+XG48L3N2ZWx0ZTpoZWFkPlxuXG48aDE+R3JlYXQhPC9oMT5cbjxwPkdvIGFoZWFkIGFuZCBjcmVhdGUgYSA8YSBocmVmPVwiL2NyZWF0ZV9jZXJ0aWZpY2F0ZVwiPm5ldyBjZXJ0aWZpY2F0ZSE8L2E+PC9wPlxuTWFrZSBzdXJlIHRoYXQgdGhlc2UgaW1hZ2VzIGFyZSB1cGxvYWRlZC4uLlxuPGhyPlxuXG5cblx0PGRpdiBzdHlsZT1cImRpc3BsYXk6ZmxleDt3aWR0aDoxMDAlXCI+XG5cdFx0PERhdGFVcGxvYWQgY2xhc3M9XCJmbGV4XCIgb3JnYW5pemF0aW9uPXt1c2VyLm9yZ2FuaXphdGlvbn0gcG9zdD17dXNlci5wb3N0fSBuYW1lPXt1c2VyLm5hbWV9IC8+XG5cdFx0PEltYWdlVXBsb2FkIGNsYXNzPVwiZmxleFwiIGF2YXRhcj17dXNlci5sb2dvfSBuYW1lPXtcImxvZ29cIn0vPlxuXHRcdDxJbWFnZVVwbG9hZCBjbGFzcz1cImZsZXhcIiBhdmF0YXI9e3VzZXIuc2lnbmF0dXJlfSBuYW1lPXtcInNpZ25hdHVyZVwifS8+XG5cdDwvZGl2PlxuPGhyPiJdLCJuYW1lcyI6WyJGb3JtRGF0YSJdLCJtYXBwaW5ncyI6Ijs7O0FBQUE7QUFDQSxXQUFjLEdBQUcsT0FBTyxJQUFJLElBQUksUUFBUSxHQUFHLElBQUksQ0FBQyxRQUFRLEdBQUcsTUFBTSxDQUFDLFFBQVE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0M4Q2xFLG9CQUFxRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7MERBRjNCLEdBQU07Ozs7O0dBQWhDLG9CQUE0Qzs7O2tGQUFsQixHQUFNOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztpQkFEM0IsR0FBTTs7Ozs7Ozs7Ozs7c0JBRmIsR0FBSTthQUFDLHVCQUFxQjs7Ozs7OzthQVE4QixjQUFZOzs7Ozs7Ozs7O3NDQVJwRSxHQUFJOzZCQUFDLHVCQUFxQjs7Ozs7Ozs7OytCQVE4QixjQUFZOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7R0FUMUUsb0JBWU07R0FYTCxvQkFBb0M7Ozs7OztHQU9qQyxvQkFBNEg7O0dBQ3hILG9CQUF3RTs7O0dBQ3hFLG9CQUE2SDs7Ozs7Ozs7Ozs7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
